<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">


<!--
This element is a container which resizes together with a browser window, starting from specified default width.
It resizes within given `minWidth` and `maxWidth` and it's breaking points are specified by user `step` attribute.


Example:

    <responsive-container></responsive-container>

@group Seed Elements
@element responsive-container
@demo demo/index.html
@hero hero.svg
-->
<dom-module id="responsive-container">

  <template>
    <style>
      
      :host {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        @apply(--layout-center-justified);
      }
      
    </style>
    <iron-media-query id="lowerLimit" query-matches="{{_lowerMatches}}"></iron-media-query>
    <iron-media-query id="upperLimit" query-matches="{{_upperMatches}}"></iron-media-query>
      <content></content>
  </template>

</dom-module>

<script>

  Polymer({

    is: 'responsive-container',

    properties: {
      _lowerMatches: {
        type:Boolean,
        observer:'_lowerMatch'
      },
      _upperMatches: {
        type:Boolean,
        observer:'upperMatch'
      },
      /**
       * Current value of the width that is calculated according to window size. 
       */
      currentWidth: {
        type:Number,
        observer: 'recalcQueries'
      },
      /**
       * Preferred (and maximum possible) width of the container, if window size allows it.
       * Container will not stretch over this width.
       */
      width: {
        type:Number,
        value: 1000,
        observer: '_widthSet',
      },
      /**
       * Minimum allowed width of the container. Container will not resize below this width. 
       */
      minWidth: {
        type:Number,
        value: 220,
      },
      /**
       * Container width is incremented/decremented by step value until it best fits window size.
       */
      step: {
        type:Number,
        value: 200,
      }
    },
    /*
     * This counter is used to track changes in window size 
     */
    _counter:0,
    /*
     * Timer internaly used to activate recalculation of the container width once window changes were finished. 
     */
    _timer:null,
    /**
     * When window size has gone below lower limit (newVal == false), new container width is calculated. Oterwise, nothing is done.
     * @param newVal New value of the query match
     * @param oldVal Old value of the query match
     */
    _lowerMatch:function(newVal, oldVal) {
      if (!newVal) {
        // Make sure we don't go below minimum width
        if (this.currentWidth - this.step >=this.minWidth) {
          this.currentWidth -= this.step; 
        }
      }
    },
    /**
     * When window width grows above upper limit (newVal == false), new container width is calculated. Oterwise, nothing is done.
     */
    upperMatch: function(newVal, oldVal) {
      if (!newVal) {
        // Make sure we don't go over maximum width
        if (this.currentWidth + this.step <=this.width) {
          this.currentWidth += this.step;
        }
      }
    },
    /**
     * Once that new width is calculated due to the changes in window size, this function is invoked.
     * It updates container width and media queries, so that changes in window size trigger queries again.
     *  
     * @param {number} newVal New width of the container.
     * @param {number} oldVal Old width of the container.
     */
    recalcQueries: function(newVal, oldVal) {
        this.style.width = newVal+"px"; 
        this.$.lowerLimit.queryChanged("(min-width: "+(newVal+this.step/2)+"px)");
        this.$.upperLimit.queryChanged("(max-width: "+(newVal+(this.step*3)/2)+"px)");
      
    },
    /**
     * If user really quickly resizes window, standard media query mechanism fails to react quickly enough
     * so additional mechanism is added to solve this problem, which relies on tracking window resize events.
     * This function is invoked each time window is resized, and it starts timer which waits for resizing to settle
     * and then recalculates container size to make sure that it is right.
     */
    _windowResized:function(_this, e) {
      if(_this._timer == null) {
        _this._timer = setInterval(function(component) {
          function handler(e) {
            component.debounceResize(component);
          }
          return handler;
        }(_this),100); 
      }
      _this._counter++;
    },
    /**
     * Checks if there were any window size changes in last timer interval.
     * If there were not (_counter == -1), it cancels timer and initiates recalculation of container width.
     * It there were changes, it resets change indicator and lets timer to go one more interval before it checks again.
     */
    debounceResize:function(_this) {
      if (_this._counter == -1) {
        /*
         * This means that from previous timeout there were no changes in size, so we will do update.
         */
         _this.updateTresholds();
         _this._counter = 0;
         clearInterval(_this._timer);
         _this._timer = null;
         return;
      }
      _this._counter = -1;
    },
    /**
     * Observer of the width property. Copies it into the currentWidth propery to 
     * kick-in initial calculation of the container width.
     */
    _widthSet:function(newVal, oldVals) {
      this.currentWidth = newVal;
    },

    // Element Lifecycle
    ready: function() {
      /*
       * Listen to window resize events to be able to react on quick changes which are
       * not properly handled by using just media queries. 
       */
      window.addEventListener('resize', function(component) {
        function handler(e) {
          component._windowResized(component, e);
        }
        return handler;
      }(this));
    },

    attached: function() {
      /**
       * Makes sure that component width is calculated once it is attached to the document.
       */
      this.updateTresholds();
    },
    /**
     * This function checks width of the window and tries to place 
     * lower and upper media query breaking points on the left and right of the window edge, respectively.
     * While doing so, it also considers specified minimum and maximum width of the container.
     * This function should be called from outside if from some reason component does not react to change in window width automaticaly. 
     */
    updateTresholds: function() {
      // Get width of the window
      var newWidth = this._getWidth();
      // Get current lower media query value
      var current = this.currentWidth + this.step/2;
      // Determine in which direction we are moving media query lower breaking point - left (-1) or right(+1)
      var factor = -1;
      if (current < newWidth) {
        factor = +1;
      }
      // Move breaking point until window egde is between lower and upper
      var cnt = 0;
      while(!(Math.abs(newWidth - current) <=this.step && newWidth>current)) {
        current += factor*this.step;
        if (cnt++ > 10) break;
      };
      // Here is the width of the container that is calculated. 
      var calculatedWidth = current - this.step/2;
      // Now just make sure that calcluated value is between specified max and min value
      if (this.width>0) {
        while (this.width < calculatedWidth) {
          calculatedWidth -=this.step;
        }
      }
      if (this.minWidth>0) {
        while (this.minWidth > calculatedWidth) {
          calculatedWidth += this.step;
        }
      }
      // Set container width variable, which trigers observer which sets container size and updates media queries 
      this.currentWidth = calculatedWidth;
    },
    /**
     * Obtain window width
     * @returns {number} Width of the browser window.
     */
    _getWidth: function() {
      var winW = this.width;
      if (document.body && document.body.offsetWidth) {
        winW = document.body.offsetWidth;
      }
      if (document.compatMode=='CSS1Compat' &&
          document.documentElement &&
          document.documentElement.offsetWidth ) {
        winW = document.documentElement.offsetWidth;
      }
      if (window.innerWidth && window.innerHeight) {
        winW = window.innerWidth;
      }
      return winW;      
    }
  });

</script>
